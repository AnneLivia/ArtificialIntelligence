# -*- coding: utf-8 -*-
"""Python.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1NYPqtWOrCD9pxVpg2Wh8Gk1HJPCLnBtY

Importing libraries (packages)
"""

import sys
import math
import random
import time
import threading
import time
from functools import reduce

"""Output and input functions"""

print("Hello World"); # finishes with \n
word = input("Insert a word: "); 
n = int(input("insert a number: "));
print("The number is: ", n);

variable = (1 + 
            2 
            + 3);

'''
  comments of more than 
  one line is done in this way
'''
print("Hi %s, the answer is: "%word, end="");
print("%d + %d = %.02f"%(n, variable, n / variable));

print("%d %s %.2f %c"%(2, "l", 2.2, 'a'))

# creating a separator
print(16,1,1997, sep="/");

"""Data type of a variable in python is automatically assigned

in python there are integer, float, complex number, string, booleans, list...
"""

v = 1
print(type(v));
v = "strings";
print(type(v));
print(sys.maxsize); # maximum size of a integer in python (there's no limit to the size of a int in python)
print(sys.float_info.max); # maximum of a float


#complex number = real part + imaginary
co = 5 + 6j;
print(type(co));

print(False and True);

stringg = ''' this type of triple quote allows to insert ' and " without using \\' and \\" '''
print(stringg)

# cast
print(chr(65));
print(ord('A'));
print(int(6.5));
print(str(65.22));

"""Math functions from math module
Modules in Python are simply Python files with a .py extension. 
A Python module can have a set of functions, classes or variables defined and implemented.
A package is a collection of Python modules
"""

print(5 + 2)
print(5 ** 2) # pow
print(5 / 2)
print(5 % 2)
print(5 // 2) # integer division

i = 1
i+=1 # i++ doesn't work
print(i)

# math functions from math module
print(abs(2));
print(max(2, 5));
print(min(2, 1));
print(math.ceil(2.5));
print(math.floor(2.5));
print(math.sqrt(4));
print(math.factorial(9));
print(math.pow(2, 4));
print(round(5.4));
print(math.sin(2));
print(math.tan(2));
print(math.exp(2));
print(math.log(math.exp(1)));
print(math.atan(2));
print(math.pi);
# many many others

"""Gereneting random values from random module"""

print(random.randint(1, 101)); # random number from 1 to 101
print(math.inf > 0); 
print(math.inf - math.inf); # NaN is infinity (Not a Number)

"""Relational and logical operations"""

year = 1979
if year == 2019:
  print("We're not in 2019")
elif year == 2020: 
  print("We're in 2020")
elif year >= 2021:
  print("We're after 2020")
elif year != 1979 and year < 1980:
  print("We're in 70\'s and it\'s not 79") 
else:
  print("it's 79")

age = 17
vote = False
if age >= 16:
  if not (vote == True):
    print("doesn't vote yet")
  else:
    print("vote")
else:
  print("doesn't vote yet")

print (True or False)
print (True and True)
print (not False)

# ternary operator
x = 1 if 3 > 2 else 0
print(x)

"""some string operations"""

stringf = "hahahihi"
print(len(stringf))
print("First char: ", stringf[0])
print("Last char: ", stringf[-1])
print("First 2 chars: ", stringf[:2])
print("second to third char: ", stringf[1:3])
print(stringf[0:-1:2]) # from first index to last and skip the next one

# can't change char from a array in this way
#'str' object does not support item assignment
# stringf[0] = 'c' # wrong
#alternative
stringf = stringf.replace('ha', 'KKKK')
print(stringf)
# adding another word to the string
stringf = stringf[:2] + "adding Here" + stringf[3:]
print(stringf)
stringgg = "WoRd"
print("Uppercase: ", stringgg.upper())
print("Lowercase: ", stringgg.lower())
print("Checking if word or char is in something: ", ("adding" in stringf))
print("Checking if word or char is in something: ", ("Hihahahis" not in stringf))
# first index of a match
print("Checking first index of a match: ", stringf.find("Here"))

# removing (strip something from string)
print("           hi         ".strip())
print("           hi         ".lstrip()) # removing from left
print("           hi         ".rstrip()) # removing from right

# convert list into string and separate into spaces
print(" ".join(["Some", "Words"]))
# string into a list
print("String, Car, Ball".split(","))

# format output
int1 = int2 = 2
print(f'{int1} + {int2} = {int1+int2}')


print("Str123".isalnum())
print("str".isalpha())
print("123".isdigit())

"""List operations
list have mutable data 
mutable = can be change
not mutable = cannot be change (touple is an example)
"""

l1 = [1, "string", True, 2.22]
print("Length: ", len(l1))
print("Word: ", l1[0])
print("Word: ", l1[-1])
print("Word: ", l1[::-1])
print("Word: ", l1)
l1[0] = 2
l1[2:3] = ["ha", "hi"] # adding new item
print("Word: ", l1)
l1[2:2] = ["ooooo"]
print("Word: ", l1)
l1.insert(2, "hahaa")
print("Word: ", l1)

l2 = l1 + ["haha", 4444, 444]
print(l2)
l2.remove("ooooo")
print(l2)
l2.pop()
print(l2)
l3 = [[1,2], [3,4]]
print(l3[0][0])
print([3,4] in l3)
print("min in a list", min([1,3,-1,4]))
print("max in a list", max([1,3,-1,4]))

"""loops ( for and while )"""

w = 1
while w < 10:
  print(w)
  w+=1

w2 = 0

while w2 < 20:
  if w2 % 2 == 0:
    print(w2)
  elif w2 == 9:
    break
  w2+=1

print('\n\n\n')
l4 = [1, 3.2, "livia"]
while len(l4):
  print(l4.pop())



for i in range(0, 10): # from 0 to 9
  print(i, sep=" ", end="")

print('\n\n\n')
l4 = [1, 3.2, "livia"]
for x in l4:
  print(x)

print('\n\n\n')
for x in [1,2,3,4]:
  print(x)

"""iterators = allow to cycle through values"""

l5 = [1, 2, 3, 4]
itr = iter(l5)
print(next(itr))
print(next(itr))
print(next(itr))
print(next(itr))

"""range function"""

print(list(range(0,10,2)))

nlist = [list(range(1,4)), list(range(4,7)), list(range(7, 10))]
print(nlist)
for i in range(0, 3):
  for j in range(0, 3):
    print(nlist[i][j], " ", end="")
  print()

"""tuples = imutable = cannot be change

list is []

tuple = ()
"""

t1 = (1, 3.2, "l")
print("length: ", len(t1))
print("last", t1[-1])
print("reverse", t1[::-1])

"""dictionaries associates key with value (duplicate keys are not allowed)"""

languages = {
    "best1" : "c++",
    "best2" : "python"
}

print(languages["best1"])
print("len: ", len(languages))

languages["best1"] = "c"
print(languages["best1"])

languages["best3"] = "java"
print(languages)

# change to list
print(list(languages.items()))

print(list(languages.keys()))
print(list(languages.values()))


# detele item

del languages["best2"]
print(languages)
print(languages.pop("best3"))

languages["best3"] = "c++"
languages["best4"] = "php"
languages["best5"] = "javascript"
languages["best6"] = "ruby"
languages["best7"] = "matlab"

print("c" in languages)

# run through keys
for i in languages:
  print(i)
# run through values
for i in languages.values():
  print(i)


# printing dictionary in a formated way
dd = {"name": "bread", "price": .80}
print("%(name)s costs R$ %(price).2f" %dd)

"""Set is a list that is unorder that has unique values

tuple = ()
list = []
set = {}
"""

s1 = set(["haha", 1])
s2 = {"haha", 1}
print("Length: ", len(s1))

# joing sets
s3 = s1 | s2
print(s3)
s3.add("jaja")
print(s3)
s3.discard("haha")
print(s3)
print("random", s3.pop()) # random is removed
# adding values
s4 = {"kokoko", "kikii"}
s3 |= s4
print(s3)
# get the intersection of values
print(s3.intersection(s2))
# get values in s3 but not in s2
print(s3.difference(s2)) 
# get all unique values
print(s3.symmetric_difference(s2)) 
# clear the set
s3.clear()
print(s3) 

# fronzenset is a set that cannot be change in any way

s4 = frozenset(["haha", "hihi"])
print(s4)


s5 = {1, 2, 3, 4}
s6 = {2, 3}

print("is s6 a subset of s5?", s6.issubset(s5))
print("is s6 a superset of s5?", s6.issuperset(s5))
print("is s5 a superset of s6?", s5.issuperset(s6))
print(s5.union(s6))

l1 = list(s5)
s6.add(100)
l2 = list(s6)

s4 = set(l1)
s4 |= set(l2)
print(s4)

"""function in python"""

# can define data type if i want
# define default number too
def add(n1: int = 1, n2: int = 2):
  return n1 + n2

print(add(8,9))
print(add())
print(add("ss ", "ss "))

# can get a list of values
def sumlist(*args):
  sum = 0
  for arg in args:
    sum+=arg
  return sum

print(sumlist(1,2,3,4,4,5,5,6))

# returning more than one value
def next_2(num):
  return num + 1, num + 2

i1, i2 = next_2(4)

print(i1, i2)

# anonimous fuction lambda
def mult_by(n1):
  return lambda x: x * n1

print("3 * 5 = ", (mult_by(3)(5)))

# pass a function to a function
def mult_l(list, func):
  for x in list:
    print(func(x))
  
mult_by4 = mult_by(4)
print("\n\n\n")
print(mult_l(list(range(1,5)), mult_by4))

# list of functions

functions = [lambda x: x ** 2,
             lambda x: x + 2,
             lambda x: x - 2]

print(functions[1](2))

"""Python's map() is a built-in function that allows you to process and transform all the items in an iterable without using an explicit for loop"""

lists = range(1, 5)
liststimes2 = lambda x: x * 2
print(list(map(liststimes2, lists)))

"""The filter() method filters the given sequence with the help of a function that tests each element in the sequence to be true or not."""

# print even values of a list
print(list(filter(lambda x: x % 2 == 0, range(1, 11))))

"""reduce(func, seq) =: receives a list and return a single result"""

print(reduce((lambda x, y: x + y), range(1,6))) # calculates ((((1+2)+3)+4)+5)

"""Exception Handling, random erros"""

while True:
  try:
    number = int(input("Enter a number: "))
    break
  except ValueError:
    print("You didn't enter a number") # get especific error
  except:
    print("unknown error") # get any error

print("Ok")

"""File Input and output
w = write
r = read
a = append
"""

# file is going to be closed automatically by using with
# need \ to continue next line
with open("mydata.txt", mode="w", encoding="utf-8") as myfile:
  myfile.write("random text\nrandom")

with open("mydata.txt", mode="r", encoding="utf-8") as myfile:
  print(myfile.read())

print(myfile.closed) # to ensure the file is closed

f = open("mydata.txt", "r")

# can do this f = open('workfile', 'w')
print(f.read())
# reads a single line from the file; a newline character (\n) 
print(f.readline())

f.seek(0); # return to a given positon, default is 0
print("\n\n\n")
for line in f:
  print(line, end='')
f.close()

f = open("mydata.txt", "a")
f.write("\nThis is a test")

f.close()
print("\n\n\n")
with open("mydata.txt", mode="r") as f:
  print(f.read())

"""Classes and Objects
along with getters and setters
along with inheritance and Polymorphism and magic functions
"""

class Neuron:
  def __init__(self, weight, bias = "1"): # is going to be created everytime we instantiate this class (constructor), self is the this in c++
    self.weight = weight
    self.bias = bias
  # getter
  @property
  def weight(self):
    print("Return weight")
    return self.__weight # in getter and setter, attributes starts with _

  @weight.setter
  def weight(self, weight):
      self.__weight = weight

  @property
  def bias(self):
    print("Return bias")
    return self._bias # in getter and setter, attributes starts with _

  @bias.setter
  def bias(self, bias):
    if bias.isdigit():
      self.__bias = bias
    else:
      print("Not a digit")

  def getIdentity(self):
    return self.weight

n = Neuron(20)

n.weight = 10
n.bias = "2"

print(n.getIdentity())


class Node:
  def __init__(self, value1, value2):
    self.value1 = value1
    self.value2 = value2
  
  def getValue1(self):
    return self._value1

  def setValue1(self, value):
    self._value1 = value

  def getValue2(self):
    return self._value2

  def setValue2(self, value):
    self._value2 = value
  
  value1 = property(getValue1, setValue1)

  value2 = property(getValue2, setValue2)

n = Node(10, 11)
n.setValue2(2)
print(n.getValue2())


class Animal:
  def __init__(self, nome="unknown", weight = 0):
    self.name = nome
    self.weight = weight
  @property
  def name(self):
    return self.__name
  @name.setter
  def name(self, name):
     self.__name = name
  def make_noise(self):
    return "asdhihwd"
  def __str__(self):
    # used to format an answer when using print
    return "{} is a {} and says {}".format(self.__name, type(self.__name), self.make_noise())
  # magic methods used for operator overloading similar in c++
  def __gt__(self, anima2):
    if self.weight > anima2.weight:
      return True
    else:
      return False
  # other magic functions
  '''
     __eq__ : Equal
     __ne__ : Not Equal
     __lt__ : Less Than
     __gt__ : Greater Than
     __le__ : Less Than or Equal
     __ge__ : Greater Than or Equal
     __add__ : Addition
     __sub__ : Subtraction
     __mul__ : Multiplication
     __div__ : Division
     __mod__ : Modulus

  '''
# inherits all from animal
class Dog(Animal):
  def __init__(self, name = "unknown", owner="unknown", weight = 0):
    Animal.__init__(self, name, weight)
    self.__owner = owner
  
  # overwriting str function from super
  def __str__(self):
    return super().__str__() + "and has owner whose name is: " + self.__owner

a = Animal("Call", 100)
print(a)
dog = Dog("sa", "kk", 150)
print(dog)
print(a < dog)

"""Threads = block of code (execute and sleep, etc.)
Python threading allows you to have different parts of your program run concurrently and can simplify your design.
"""

def execute_thread(i):
  print("Thread {} sleeps at {}".format(i, 
                                        time.strftime("%Y-%m-%d %H:%<:%S", time.gmtime())))
  rand_sleep_time = random.randint(1,5)
  time.sleep(rand_sleep_time)
  print("Thread {} stops sleep at {}".format(i, 
                                         time.strftime("%Y-%m-%d %H:%<:%S", time.gmtime())))

# 10 threads
for i in range(10):
  thread = threading.Thread(target=execute_thread, args=(i, ))
  thread.start()
  print("Active threads: ", threading.activeCount())
  print("Thread objects: ", threading.enumerate())

"""Regular Expressions"""

import re

if re.search("ape", "the ape at the apex"):
  print("there's an ape")

allapes = re.findall("ape", "the ape at the apex")
for i in allapes:
  print(i)

"""sql in python"""

import sqlite3
import csv
import sys

def printDB():
  try:
    result = theCursor.execute("SELECT * FROM person") # i've stopped here
    for row in result:
      print("id: ", row[0])
      print("name: ", row[1])
      print("age: ", row[2])
  except sqlite3.OperationError:
    print("Table does not exist")
  except:
    print("Couldn't get data")

db_connect = sqlite3.connect('teste.db')
print("Database created")
# transverse the record of the database
theCursor = db_connect.cursor()

# create the table
try:
  db_connect.execute("DROP TABLE person")
  db_connect.execute("CREATE TABLE person (id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, name VARCHAR, age INTEGER);")
  # commit that change
  db_connect.commit()
  print("Table created")
except sqlite3.OperationalError:
  print("Error creating table")

# add person to the database
try:
  db_connect.execute("INSERT INTO person (name, age) VALUES ('livia', 23),"+
                                                     "('anne', 20), ('anne livia', 23);")
  # commit that change
  db_connect.commit()
  print("data inserted")
except sqlite3.OperationError:
  print("Error insert data")

printDB()

# close database
db_connect.close()

"""Recursive functions (functions that needs itself to solve a problem)
the process of solve some problem repeats in the same function
the function can be solved in smaller parts
example fatorial


all files in python are a modules. if i want to create a file with math funtions name mathfunction, I can import this file in another file by using
import mathfunction, if i want to import only a especific function I can do
from mathfunction import mult_matrix for example
"""

def fatorial(num):
  if num <= 1:
    return 1
  else:
    return num * fatorial(num - 1)

print("Fatorial of 5: ", fatorial(5))

def fibonacci(num):
  if num <= 2:
    return 1
  else:
    return fibonacci(num - 1) + fibonacci(num - 2)

print("5th number of the fibonacci sequence: ", fibonacci(5)) 

# depth first search
def dfs(node, visited, graph):
  if not visited[node]:
    print("Visiting node ", node)
    visited[node] = True
    for i in graph[node]:
      if not visited[i]:
        dfs(i, visited, graph)
    
graph = [[2, 3],
         [5, 1, 3],
         [1, 2],
         [2, 3],
         [2],
         [0]]

visited = list(map(lambda x: False, range(len(graph))))

# could be in this way too using list compression
# visited = list(False for x in range(len(graph)))

for v in range(len(graph)):
  if not visited[v]:
    dfs(v, visited, graph)
    print(visited)